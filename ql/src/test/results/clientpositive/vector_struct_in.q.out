PREHOOK: query: create table test_1_n1 (`id` string, `lineid` string) stored as orc
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@test_1_n1
POSTHOOK: query: create table test_1_n1 (`id` string, `lineid` string) stored as orc
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@test_1_n1
PREHOOK: query: insert into table test_1_n1 values ('one','1'), ('seven','1')
PREHOOK: type: QUERY
PREHOOK: Input: _dummy_database@_dummy_table
PREHOOK: Output: default@test_1_n1
POSTHOOK: query: insert into table test_1_n1 values ('one','1'), ('seven','1')
POSTHOOK: type: QUERY
POSTHOOK: Input: _dummy_database@_dummy_table
POSTHOOK: Output: default@test_1_n1
POSTHOOK: Lineage: test_1_n1.id SCRIPT []
POSTHOOK: Lineage: test_1_n1.lineid SCRIPT []
PREHOOK: query: explain vectorization expression
select * from test_1_n1 where struct(`id`, `lineid`)
IN (
struct('two','3'),
struct('three','1'),
struct('one','1'),
struct('five','2'),
struct('six','1'),
struct('eight','1'),
struct('seven','1'),
struct('nine','1'),
struct('ten','1')
)
PREHOOK: type: QUERY
PREHOOK: Input: default@test_1_n1
#### A masked pattern was here ####
POSTHOOK: query: explain vectorization expression
select * from test_1_n1 where struct(`id`, `lineid`)
IN (
struct('two','3'),
struct('three','1'),
struct('one','1'),
struct('five','2'),
struct('six','1'),
struct('eight','1'),
struct('seven','1'),
struct('nine','1'),
struct('ten','1')
)
POSTHOOK: type: QUERY
POSTHOOK: Input: default@test_1_n1
#### A masked pattern was here ####
PLAN VECTORIZATION:
  enabled: true
  enabledConditionsMet: [hive.vectorized.execution.enabled IS true]

STAGE DEPENDENCIES:
  Stage-1 is a root stage
  Stage-0 depends on stages: Stage-1

STAGE PLANS:
  Stage: Stage-1
    Map Reduce
      Map Operator Tree:
          TableScan
            alias: test_1_n1
            filterExpr: (struct(id,lineid)) IN (const struct('two','3'), const struct('three','1'), const struct('one','1'), const struct('five','2'), const struct('six','1'), const struct('eight','1'), const struct('seven','1'), const struct('nine','1'), const struct('ten','1')) (type: boolean)
            Statistics: Num rows: 2 Data size: 346 Basic stats: COMPLETE Column stats: NONE
            TableScan Vectorization:
                native: true
            Filter Operator
              Filter Vectorization:
                  className: VectorFilterOperator
                  native: true
                  predicateExpression: FilterStructColumnInList(structExpressions [col 0:string, col 1:string], fieldVectorColumnTypes [BYTES, BYTES], structColumnMap [0, 1])
              predicate: (struct(id,lineid)) IN (const struct('two','3'), const struct('three','1'), const struct('one','1'), const struct('five','2'), const struct('six','1'), const struct('eight','1'), const struct('seven','1'), const struct('nine','1'), const struct('ten','1')) (type: boolean)
              Statistics: Num rows: 2 Data size: 346 Basic stats: COMPLETE Column stats: NONE
              Select Operator
                expressions: id (type: string), lineid (type: string)
                outputColumnNames: _col0, _col1
                Select Vectorization:
                    className: VectorSelectOperator
                    native: true
                    projectedOutputColumnNums: [0, 1]
                Statistics: Num rows: 2 Data size: 346 Basic stats: COMPLETE Column stats: NONE
                File Output Operator
                  compressed: false
                  File Sink Vectorization:
                      className: VectorFileSinkOperator
                      native: false
                  Statistics: Num rows: 2 Data size: 346 Basic stats: COMPLETE Column stats: NONE
                  table:
                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat
                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat
                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe
      Execution mode: vectorized
      Map Vectorization:
          enabled: true
          enabledConditionsMet: hive.vectorized.use.vectorized.input.format IS true
          inputFormatFeatureSupport: [DECIMAL_64]
          featureSupportInUse: [DECIMAL_64]
          inputFileFormats: org.apache.hadoop.hive.ql.io.orc.OrcInputFormat
          allNative: false
          usesVectorUDFAdaptor: false
          vectorized: true

  Stage: Stage-0
    Fetch Operator
      limit: -1
      Processor Tree:
        ListSink

PREHOOK: query: select * from test_1_n1 where struct(`id`, `lineid`)
IN (
struct('two','3'),
struct('three','1'),
struct('one','1'),
struct('five','2'),
struct('six','1'),
struct('eight','1'),
struct('seven','1'),
struct('nine','1'),
struct('ten','1')
)
PREHOOK: type: QUERY
PREHOOK: Input: default@test_1_n1
#### A masked pattern was here ####
POSTHOOK: query: select * from test_1_n1 where struct(`id`, `lineid`)
IN (
struct('two','3'),
struct('three','1'),
struct('one','1'),
struct('five','2'),
struct('six','1'),
struct('eight','1'),
struct('seven','1'),
struct('nine','1'),
struct('ten','1')
)
POSTHOOK: type: QUERY
POSTHOOK: Input: default@test_1_n1
#### A masked pattern was here ####
one	1
seven	1
PREHOOK: query: explain vectorization expression
select `id`, `lineid`, struct(`id`, `lineid`)
IN (
struct('two','3'),
struct('three','1'),
struct('one','1'),
struct('five','2'),
struct('six','1'),
struct('eight','1'),
struct('seven','1'),
struct('nine','1'),
struct('ten','1')
) as b from test_1_n1
PREHOOK: type: QUERY
PREHOOK: Input: default@test_1_n1
#### A masked pattern was here ####
POSTHOOK: query: explain vectorization expression
select `id`, `lineid`, struct(`id`, `lineid`)
IN (
struct('two','3'),
struct('three','1'),
struct('one','1'),
struct('five','2'),
struct('six','1'),
struct('eight','1'),
struct('seven','1'),
struct('nine','1'),
struct('ten','1')
) as b from test_1_n1
POSTHOOK: type: QUERY
POSTHOOK: Input: default@test_1_n1
#### A masked pattern was here ####
PLAN VECTORIZATION:
  enabled: true
  enabledConditionsMet: [hive.vectorized.execution.enabled IS true]

STAGE DEPENDENCIES:
  Stage-1 is a root stage
  Stage-0 depends on stages: Stage-1

STAGE PLANS:
  Stage: Stage-1
    Map Reduce
      Map Operator Tree:
          TableScan
            alias: test_1_n1
            Statistics: Num rows: 2 Data size: 346 Basic stats: COMPLETE Column stats: NONE
            TableScan Vectorization:
                native: true
            Select Operator
              expressions: id (type: string), lineid (type: string), (((id = 'two') and (lineid = '3')) or ((id = 'three') and (lineid = '1')) or ((id = 'one') and (lineid = '1')) or ((id = 'five') and (lineid = '2')) or ((id = 'six') and (lineid = '1')) or ((id = 'eight') and (lineid = '1')) or ((id = 'seven') and (lineid = '1')) or ((id = 'nine') and (lineid = '1')) or ((id = 'ten') and (lineid = '1'))) (type: boolean)
              outputColumnNames: _col0, _col1, _col2
              Select Vectorization:
                  className: VectorSelectOperator
                  native: true
                  projectedOutputColumnNums: [0, 1, 3]
                  selectExpressions: VectorUDFAdaptor((((id = 'two') and (lineid = '3')) or ((id = 'three') and (lineid = '1')) or ((id = 'one') and (lineid = '1')) or ((id = 'five') and (lineid = '2')) or ((id = 'six') and (lineid = '1')) or ((id = 'eight') and (lineid = '1')) or ((id = 'seven') and (lineid = '1')) or ((id = 'nine') and (lineid = '1')) or ((id = 'ten') and (lineid = '1'))))(children: ColAndCol(col 3:boolean, col 4:boolean)(children: StringGroupColEqualStringScalar(col 0:string, val two) -> 3:boolean, StringGroupColEqualStringScalar(col 1:string, val 3) -> 4:boolean) -> 5:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: StringGroupColEqualStringScalar(col 0:string, val three) -> 3:boolean, StringGroupColEqualStringScalar(col 1:string, val 1) -> 4:boolean) -> 6:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: StringGroupColEqualStringScalar(col 0:string, val one) -> 3:boolean, StringGroupColEqualStringScalar(col 1:string, val 1) -> 4:boolean) -> 7:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: StringGroupColEqualStringScalar(col 0:string, val five) -> 3:boolean, StringGroupColEqualStringScalar(col 1:string, val 2) -> 4:boolean) -> 8:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: StringGroupColEqualStringScalar(col 0:string, val six) -> 3:boolean, StringGroupColEqualStringScalar(col 1:string, val 1) -> 4:boolean) -> 9:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: StringGroupColEqualStringScalar(col 0:string, val eight) -> 3:boolean, StringGroupColEqualStringScalar(col 1:string, val 1) -> 4:boolean) -> 10:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: StringGroupColEqualStringScalar(col 0:string, val seven) -> 3:boolean, StringGroupColEqualStringScalar(col 1:string, val 1) -> 4:boolean) -> 11:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: StringGroupColEqualStringScalar(col 0:string, val nine) -> 3:boolean, StringGroupColEqualStringScalar(col 1:string, val 1) -> 4:boolean) -> 12:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: StringGroupColEqualStringScalar(col 0:string, val ten) -> 3:boolean, StringGroupColEqualStringScalar(col 1:string, val 1) -> 4:boolean) -> 13:boolean) -> 3:boolean
              Statistics: Num rows: 2 Data size: 346 Basic stats: COMPLETE Column stats: NONE
              File Output Operator
                compressed: false
                File Sink Vectorization:
                    className: VectorFileSinkOperator
                    native: false
                Statistics: Num rows: 2 Data size: 346 Basic stats: COMPLETE Column stats: NONE
                table:
                    input format: org.apache.hadoop.mapred.SequenceFileInputFormat
                    output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat
                    serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe
      Execution mode: vectorized
      Map Vectorization:
          enabled: true
          enabledConditionsMet: hive.vectorized.use.vectorized.input.format IS true
          inputFormatFeatureSupport: [DECIMAL_64]
          featureSupportInUse: [DECIMAL_64]
          inputFileFormats: org.apache.hadoop.hive.ql.io.orc.OrcInputFormat
          allNative: false
          usesVectorUDFAdaptor: true
          vectorized: true

  Stage: Stage-0
    Fetch Operator
      limit: -1
      Processor Tree:
        ListSink

PREHOOK: query: select `id`, `lineid`, struct(`id`, `lineid`)
IN (
struct('two','3'),
struct('three','1'),
struct('one','1'),
struct('five','2'),
struct('six','1'),
struct('eight','1'),
struct('seven','1'),
struct('nine','1'),
struct('ten','1')
) as b from test_1_n1
PREHOOK: type: QUERY
PREHOOK: Input: default@test_1_n1
#### A masked pattern was here ####
POSTHOOK: query: select `id`, `lineid`, struct(`id`, `lineid`)
IN (
struct('two','3'),
struct('three','1'),
struct('one','1'),
struct('five','2'),
struct('six','1'),
struct('eight','1'),
struct('seven','1'),
struct('nine','1'),
struct('ten','1')
) as b from test_1_n1
POSTHOOK: type: QUERY
POSTHOOK: Input: default@test_1_n1
#### A masked pattern was here ####
one	1	true
seven	1	true
PREHOOK: query: create table test_2_n1 (`id` int, `lineid` int) stored as orc
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@test_2_n1
POSTHOOK: query: create table test_2_n1 (`id` int, `lineid` int) stored as orc
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@test_2_n1
PREHOOK: query: insert into table test_2_n1 values (1,1), (7,1)
PREHOOK: type: QUERY
PREHOOK: Input: _dummy_database@_dummy_table
PREHOOK: Output: default@test_2_n1
POSTHOOK: query: insert into table test_2_n1 values (1,1), (7,1)
POSTHOOK: type: QUERY
POSTHOOK: Input: _dummy_database@_dummy_table
POSTHOOK: Output: default@test_2_n1
POSTHOOK: Lineage: test_2_n1.id SCRIPT []
POSTHOOK: Lineage: test_2_n1.lineid SCRIPT []
PREHOOK: query: explain vectorization expression
select * from test_2_n1 where struct(`id`, `lineid`)
IN (
struct(2,3),
struct(3,1),
struct(1,1),
struct(5,2),
struct(6,1),
struct(8,1),
struct(7,1),
struct(9,1),
struct(10,1)
)
PREHOOK: type: QUERY
PREHOOK: Input: default@test_2_n1
#### A masked pattern was here ####
POSTHOOK: query: explain vectorization expression
select * from test_2_n1 where struct(`id`, `lineid`)
IN (
struct(2,3),
struct(3,1),
struct(1,1),
struct(5,2),
struct(6,1),
struct(8,1),
struct(7,1),
struct(9,1),
struct(10,1)
)
POSTHOOK: type: QUERY
POSTHOOK: Input: default@test_2_n1
#### A masked pattern was here ####
PLAN VECTORIZATION:
  enabled: true
  enabledConditionsMet: [hive.vectorized.execution.enabled IS true]

STAGE DEPENDENCIES:
  Stage-1 is a root stage
  Stage-0 depends on stages: Stage-1

STAGE PLANS:
  Stage: Stage-1
    Map Reduce
      Map Operator Tree:
          TableScan
            alias: test_2_n1
            filterExpr: (struct(id,lineid)) IN (const struct(2,3), const struct(3,1), const struct(1,1), const struct(5,2), const struct(6,1), const struct(8,1), const struct(7,1), const struct(9,1), const struct(10,1)) (type: boolean)
            Statistics: Num rows: 2 Data size: 16 Basic stats: COMPLETE Column stats: NONE
            TableScan Vectorization:
                native: true
            Filter Operator
              Filter Vectorization:
                  className: VectorFilterOperator
                  native: true
                  predicateExpression: FilterStructColumnInList(structExpressions [col 0:int, col 1:int], fieldVectorColumnTypes [LONG, LONG], structColumnMap [0, 1])
              predicate: (struct(id,lineid)) IN (const struct(2,3), const struct(3,1), const struct(1,1), const struct(5,2), const struct(6,1), const struct(8,1), const struct(7,1), const struct(9,1), const struct(10,1)) (type: boolean)
              Statistics: Num rows: 2 Data size: 16 Basic stats: COMPLETE Column stats: NONE
              Select Operator
                expressions: id (type: int), lineid (type: int)
                outputColumnNames: _col0, _col1
                Select Vectorization:
                    className: VectorSelectOperator
                    native: true
                    projectedOutputColumnNums: [0, 1]
                Statistics: Num rows: 2 Data size: 16 Basic stats: COMPLETE Column stats: NONE
                File Output Operator
                  compressed: false
                  File Sink Vectorization:
                      className: VectorFileSinkOperator
                      native: false
                  Statistics: Num rows: 2 Data size: 16 Basic stats: COMPLETE Column stats: NONE
                  table:
                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat
                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat
                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe
      Execution mode: vectorized
      Map Vectorization:
          enabled: true
          enabledConditionsMet: hive.vectorized.use.vectorized.input.format IS true
          inputFormatFeatureSupport: [DECIMAL_64]
          featureSupportInUse: [DECIMAL_64]
          inputFileFormats: org.apache.hadoop.hive.ql.io.orc.OrcInputFormat
          allNative: false
          usesVectorUDFAdaptor: false
          vectorized: true

  Stage: Stage-0
    Fetch Operator
      limit: -1
      Processor Tree:
        ListSink

PREHOOK: query: select * from test_2_n1 where struct(`id`, `lineid`)
IN (
struct(2,3),
struct(3,1),
struct(1,1),
struct(5,2),
struct(6,1),
struct(8,1),
struct(7,1),
struct(9,1),
struct(10,1)
)
PREHOOK: type: QUERY
PREHOOK: Input: default@test_2_n1
#### A masked pattern was here ####
POSTHOOK: query: select * from test_2_n1 where struct(`id`, `lineid`)
IN (
struct(2,3),
struct(3,1),
struct(1,1),
struct(5,2),
struct(6,1),
struct(8,1),
struct(7,1),
struct(9,1),
struct(10,1)
)
POSTHOOK: type: QUERY
POSTHOOK: Input: default@test_2_n1
#### A masked pattern was here ####
1	1
7	1
PREHOOK: query: explain vectorization expression
select `id`, `lineid`, struct(`id`, `lineid`)
IN (
struct(2,3),
struct(3,1),
struct(1,1),
struct(5,2),
struct(6,1),
struct(8,1),
struct(7,1),
struct(9,1),
struct(10,1)
) as b from test_2_n1
PREHOOK: type: QUERY
PREHOOK: Input: default@test_2_n1
#### A masked pattern was here ####
POSTHOOK: query: explain vectorization expression
select `id`, `lineid`, struct(`id`, `lineid`)
IN (
struct(2,3),
struct(3,1),
struct(1,1),
struct(5,2),
struct(6,1),
struct(8,1),
struct(7,1),
struct(9,1),
struct(10,1)
) as b from test_2_n1
POSTHOOK: type: QUERY
POSTHOOK: Input: default@test_2_n1
#### A masked pattern was here ####
PLAN VECTORIZATION:
  enabled: true
  enabledConditionsMet: [hive.vectorized.execution.enabled IS true]

STAGE DEPENDENCIES:
  Stage-1 is a root stage
  Stage-0 depends on stages: Stage-1

STAGE PLANS:
  Stage: Stage-1
    Map Reduce
      Map Operator Tree:
          TableScan
            alias: test_2_n1
            Statistics: Num rows: 2 Data size: 16 Basic stats: COMPLETE Column stats: NONE
            TableScan Vectorization:
                native: true
            Select Operator
              expressions: id (type: int), lineid (type: int), (((id = 2) and (lineid = 3)) or ((id = 3) and (lineid = 1)) or ((id = 1) and (lineid = 1)) or ((id = 5) and (lineid = 2)) or ((id = 6) and (lineid = 1)) or ((id = 8) and (lineid = 1)) or ((id = 7) and (lineid = 1)) or ((id = 9) and (lineid = 1)) or ((id = 10) and (lineid = 1))) (type: boolean)
              outputColumnNames: _col0, _col1, _col2
              Select Vectorization:
                  className: VectorSelectOperator
                  native: true
                  projectedOutputColumnNums: [0, 1, 3]
                  selectExpressions: VectorUDFAdaptor((((id = 2) and (lineid = 3)) or ((id = 3) and (lineid = 1)) or ((id = 1) and (lineid = 1)) or ((id = 5) and (lineid = 2)) or ((id = 6) and (lineid = 1)) or ((id = 8) and (lineid = 1)) or ((id = 7) and (lineid = 1)) or ((id = 9) and (lineid = 1)) or ((id = 10) and (lineid = 1))))(children: ColAndCol(col 3:boolean, col 4:boolean)(children: LongColEqualLongScalar(col 0:int, val 2) -> 3:boolean, LongColEqualLongScalar(col 1:int, val 3) -> 4:boolean) -> 5:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: LongColEqualLongScalar(col 0:int, val 3) -> 3:boolean, LongColEqualLongScalar(col 1:int, val 1) -> 4:boolean) -> 6:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: LongColEqualLongScalar(col 0:int, val 1) -> 3:boolean, LongColEqualLongScalar(col 1:int, val 1) -> 4:boolean) -> 7:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: LongColEqualLongScalar(col 0:int, val 5) -> 3:boolean, LongColEqualLongScalar(col 1:int, val 2) -> 4:boolean) -> 8:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: LongColEqualLongScalar(col 0:int, val 6) -> 3:boolean, LongColEqualLongScalar(col 1:int, val 1) -> 4:boolean) -> 9:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: LongColEqualLongScalar(col 0:int, val 8) -> 3:boolean, LongColEqualLongScalar(col 1:int, val 1) -> 4:boolean) -> 10:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: LongColEqualLongScalar(col 0:int, val 7) -> 3:boolean, LongColEqualLongScalar(col 1:int, val 1) -> 4:boolean) -> 11:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: LongColEqualLongScalar(col 0:int, val 9) -> 3:boolean, LongColEqualLongScalar(col 1:int, val 1) -> 4:boolean) -> 12:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: LongColEqualLongScalar(col 0:int, val 10) -> 3:boolean, LongColEqualLongScalar(col 1:int, val 1) -> 4:boolean) -> 13:boolean) -> 3:boolean
              Statistics: Num rows: 2 Data size: 16 Basic stats: COMPLETE Column stats: NONE
              File Output Operator
                compressed: false
                File Sink Vectorization:
                    className: VectorFileSinkOperator
                    native: false
                Statistics: Num rows: 2 Data size: 16 Basic stats: COMPLETE Column stats: NONE
                table:
                    input format: org.apache.hadoop.mapred.SequenceFileInputFormat
                    output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat
                    serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe
      Execution mode: vectorized
      Map Vectorization:
          enabled: true
          enabledConditionsMet: hive.vectorized.use.vectorized.input.format IS true
          inputFormatFeatureSupport: [DECIMAL_64]
          featureSupportInUse: [DECIMAL_64]
          inputFileFormats: org.apache.hadoop.hive.ql.io.orc.OrcInputFormat
          allNative: false
          usesVectorUDFAdaptor: true
          vectorized: true

  Stage: Stage-0
    Fetch Operator
      limit: -1
      Processor Tree:
        ListSink

PREHOOK: query: select `id`, `lineid`, struct(`id`, `lineid`)
IN (
struct(2,3),
struct(3,1),
struct(1,1),
struct(5,2),
struct(6,1),
struct(8,1),
struct(7,1),
struct(9,1),
struct(10,1)
) as b from test_2_n1
PREHOOK: type: QUERY
PREHOOK: Input: default@test_2_n1
#### A masked pattern was here ####
POSTHOOK: query: select `id`, `lineid`, struct(`id`, `lineid`)
IN (
struct(2,3),
struct(3,1),
struct(1,1),
struct(5,2),
struct(6,1),
struct(8,1),
struct(7,1),
struct(9,1),
struct(10,1)
) as b from test_2_n1
POSTHOOK: type: QUERY
POSTHOOK: Input: default@test_2_n1
#### A masked pattern was here ####
1	1	true
7	1	true
PREHOOK: query: create table test_3 (`id` string, `lineid` int) stored as orc
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@test_3
POSTHOOK: query: create table test_3 (`id` string, `lineid` int) stored as orc
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@test_3
PREHOOK: query: insert into table test_3 values ('one',1), ('seven',1)
PREHOOK: type: QUERY
PREHOOK: Input: _dummy_database@_dummy_table
PREHOOK: Output: default@test_3
POSTHOOK: query: insert into table test_3 values ('one',1), ('seven',1)
POSTHOOK: type: QUERY
POSTHOOK: Input: _dummy_database@_dummy_table
POSTHOOK: Output: default@test_3
POSTHOOK: Lineage: test_3.id SCRIPT []
POSTHOOK: Lineage: test_3.lineid SCRIPT []
PREHOOK: query: explain vectorization expression
select * from test_3 where struct(`id`, `lineid`)
IN (
struct('two',3),
struct('three',1),
struct('one',1),
struct('five',2),
struct('six',1),
struct('eight',1),
struct('seven',1),
struct('nine',1),
struct('ten',1)
)
PREHOOK: type: QUERY
PREHOOK: Input: default@test_3
#### A masked pattern was here ####
POSTHOOK: query: explain vectorization expression
select * from test_3 where struct(`id`, `lineid`)
IN (
struct('two',3),
struct('three',1),
struct('one',1),
struct('five',2),
struct('six',1),
struct('eight',1),
struct('seven',1),
struct('nine',1),
struct('ten',1)
)
POSTHOOK: type: QUERY
POSTHOOK: Input: default@test_3
#### A masked pattern was here ####
PLAN VECTORIZATION:
  enabled: true
  enabledConditionsMet: [hive.vectorized.execution.enabled IS true]

STAGE DEPENDENCIES:
  Stage-1 is a root stage
  Stage-0 depends on stages: Stage-1

STAGE PLANS:
  Stage: Stage-1
    Map Reduce
      Map Operator Tree:
          TableScan
            alias: test_3
            filterExpr: (struct(id,lineid)) IN (const struct('two',3), const struct('three',1), const struct('one',1), const struct('five',2), const struct('six',1), const struct('eight',1), const struct('seven',1), const struct('nine',1), const struct('ten',1)) (type: boolean)
            Statistics: Num rows: 2 Data size: 184 Basic stats: COMPLETE Column stats: NONE
            TableScan Vectorization:
                native: true
            Filter Operator
              Filter Vectorization:
                  className: VectorFilterOperator
                  native: true
                  predicateExpression: FilterStructColumnInList(structExpressions [col 0:string, col 1:int], fieldVectorColumnTypes [BYTES, LONG], structColumnMap [0, 1])
              predicate: (struct(id,lineid)) IN (const struct('two',3), const struct('three',1), const struct('one',1), const struct('five',2), const struct('six',1), const struct('eight',1), const struct('seven',1), const struct('nine',1), const struct('ten',1)) (type: boolean)
              Statistics: Num rows: 2 Data size: 184 Basic stats: COMPLETE Column stats: NONE
              Select Operator
                expressions: id (type: string), lineid (type: int)
                outputColumnNames: _col0, _col1
                Select Vectorization:
                    className: VectorSelectOperator
                    native: true
                    projectedOutputColumnNums: [0, 1]
                Statistics: Num rows: 2 Data size: 184 Basic stats: COMPLETE Column stats: NONE
                File Output Operator
                  compressed: false
                  File Sink Vectorization:
                      className: VectorFileSinkOperator
                      native: false
                  Statistics: Num rows: 2 Data size: 184 Basic stats: COMPLETE Column stats: NONE
                  table:
                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat
                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat
                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe
      Execution mode: vectorized
      Map Vectorization:
          enabled: true
          enabledConditionsMet: hive.vectorized.use.vectorized.input.format IS true
          inputFormatFeatureSupport: [DECIMAL_64]
          featureSupportInUse: [DECIMAL_64]
          inputFileFormats: org.apache.hadoop.hive.ql.io.orc.OrcInputFormat
          allNative: false
          usesVectorUDFAdaptor: false
          vectorized: true

  Stage: Stage-0
    Fetch Operator
      limit: -1
      Processor Tree:
        ListSink

PREHOOK: query: select * from test_3 where struct(`id`, `lineid`)
IN (
struct('two',3),
struct('three',1),
struct('one',1),
struct('five',2),
struct('six',1),
struct('eight',1),
struct('seven',1),
struct('nine',1),
struct('ten',1)
)
PREHOOK: type: QUERY
PREHOOK: Input: default@test_3
#### A masked pattern was here ####
POSTHOOK: query: select * from test_3 where struct(`id`, `lineid`)
IN (
struct('two',3),
struct('three',1),
struct('one',1),
struct('five',2),
struct('six',1),
struct('eight',1),
struct('seven',1),
struct('nine',1),
struct('ten',1)
)
POSTHOOK: type: QUERY
POSTHOOK: Input: default@test_3
#### A masked pattern was here ####
one	1
seven	1
PREHOOK: query: explain vectorization expression
select `id`, `lineid`, struct(`id`, `lineid`)
IN (
struct('two',3),
struct('three',1),
struct('one',1),
struct('five',2),
struct('six',1),
struct('eight',1),
struct('seven',1),
struct('nine',1),
struct('ten',1)
) as b from test_3
PREHOOK: type: QUERY
PREHOOK: Input: default@test_3
#### A masked pattern was here ####
POSTHOOK: query: explain vectorization expression
select `id`, `lineid`, struct(`id`, `lineid`)
IN (
struct('two',3),
struct('three',1),
struct('one',1),
struct('five',2),
struct('six',1),
struct('eight',1),
struct('seven',1),
struct('nine',1),
struct('ten',1)
) as b from test_3
POSTHOOK: type: QUERY
POSTHOOK: Input: default@test_3
#### A masked pattern was here ####
PLAN VECTORIZATION:
  enabled: true
  enabledConditionsMet: [hive.vectorized.execution.enabled IS true]

STAGE DEPENDENCIES:
  Stage-1 is a root stage
  Stage-0 depends on stages: Stage-1

STAGE PLANS:
  Stage: Stage-1
    Map Reduce
      Map Operator Tree:
          TableScan
            alias: test_3
            Statistics: Num rows: 2 Data size: 184 Basic stats: COMPLETE Column stats: NONE
            TableScan Vectorization:
                native: true
            Select Operator
              expressions: id (type: string), lineid (type: int), (((id = 'two') and (lineid = 3)) or ((id = 'three') and (lineid = 1)) or ((id = 'one') and (lineid = 1)) or ((id = 'five') and (lineid = 2)) or ((id = 'six') and (lineid = 1)) or ((id = 'eight') and (lineid = 1)) or ((id = 'seven') and (lineid = 1)) or ((id = 'nine') and (lineid = 1)) or ((id = 'ten') and (lineid = 1))) (type: boolean)
              outputColumnNames: _col0, _col1, _col2
              Select Vectorization:
                  className: VectorSelectOperator
                  native: true
                  projectedOutputColumnNums: [0, 1, 3]
                  selectExpressions: VectorUDFAdaptor((((id = 'two') and (lineid = 3)) or ((id = 'three') and (lineid = 1)) or ((id = 'one') and (lineid = 1)) or ((id = 'five') and (lineid = 2)) or ((id = 'six') and (lineid = 1)) or ((id = 'eight') and (lineid = 1)) or ((id = 'seven') and (lineid = 1)) or ((id = 'nine') and (lineid = 1)) or ((id = 'ten') and (lineid = 1))))(children: ColAndCol(col 3:boolean, col 4:boolean)(children: StringGroupColEqualStringScalar(col 0:string, val two) -> 3:boolean, LongColEqualLongScalar(col 1:int, val 3) -> 4:boolean) -> 5:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: StringGroupColEqualStringScalar(col 0:string, val three) -> 3:boolean, LongColEqualLongScalar(col 1:int, val 1) -> 4:boolean) -> 6:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: StringGroupColEqualStringScalar(col 0:string, val one) -> 3:boolean, LongColEqualLongScalar(col 1:int, val 1) -> 4:boolean) -> 7:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: StringGroupColEqualStringScalar(col 0:string, val five) -> 3:boolean, LongColEqualLongScalar(col 1:int, val 2) -> 4:boolean) -> 8:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: StringGroupColEqualStringScalar(col 0:string, val six) -> 3:boolean, LongColEqualLongScalar(col 1:int, val 1) -> 4:boolean) -> 9:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: StringGroupColEqualStringScalar(col 0:string, val eight) -> 3:boolean, LongColEqualLongScalar(col 1:int, val 1) -> 4:boolean) -> 10:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: StringGroupColEqualStringScalar(col 0:string, val seven) -> 3:boolean, LongColEqualLongScalar(col 1:int, val 1) -> 4:boolean) -> 11:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: StringGroupColEqualStringScalar(col 0:string, val nine) -> 3:boolean, LongColEqualLongScalar(col 1:int, val 1) -> 4:boolean) -> 12:boolean, ColAndCol(col 3:boolean, col 4:boolean)(children: StringGroupColEqualStringScalar(col 0:string, val ten) -> 3:boolean, LongColEqualLongScalar(col 1:int, val 1) -> 4:boolean) -> 13:boolean) -> 3:boolean
              Statistics: Num rows: 2 Data size: 184 Basic stats: COMPLETE Column stats: NONE
              File Output Operator
                compressed: false
                File Sink Vectorization:
                    className: VectorFileSinkOperator
                    native: false
                Statistics: Num rows: 2 Data size: 184 Basic stats: COMPLETE Column stats: NONE
                table:
                    input format: org.apache.hadoop.mapred.SequenceFileInputFormat
                    output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat
                    serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe
      Execution mode: vectorized
      Map Vectorization:
          enabled: true
          enabledConditionsMet: hive.vectorized.use.vectorized.input.format IS true
          inputFormatFeatureSupport: [DECIMAL_64]
          featureSupportInUse: [DECIMAL_64]
          inputFileFormats: org.apache.hadoop.hive.ql.io.orc.OrcInputFormat
          allNative: false
          usesVectorUDFAdaptor: true
          vectorized: true

  Stage: Stage-0
    Fetch Operator
      limit: -1
      Processor Tree:
        ListSink

PREHOOK: query: select `id`, `lineid`, struct(`id`, `lineid`)
IN (
struct('two',3),
struct('three',1),
struct('one',1),
struct('five',2),
struct('six',1),
struct('eight',1),
struct('seven',1),
struct('nine',1),
struct('ten',1)
) as b from test_3
PREHOOK: type: QUERY
PREHOOK: Input: default@test_3
#### A masked pattern was here ####
POSTHOOK: query: select `id`, `lineid`, struct(`id`, `lineid`)
IN (
struct('two',3),
struct('three',1),
struct('one',1),
struct('five',2),
struct('six',1),
struct('eight',1),
struct('seven',1),
struct('nine',1),
struct('ten',1)
) as b from test_3
POSTHOOK: type: QUERY
POSTHOOK: Input: default@test_3
#### A masked pattern was here ####
one	1	true
seven	1	true
PREHOOK: query: create table test_4 (`my_bigint` bigint, `my_string` string, `my_double` double) stored as orc
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@test_4
POSTHOOK: query: create table test_4 (`my_bigint` bigint, `my_string` string, `my_double` double) stored as orc
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@test_4
PREHOOK: query: insert into table test_4 values (1, "b", 1.5), (1, "a", 0.5), (2, "b", 1.5)
PREHOOK: type: QUERY
PREHOOK: Input: _dummy_database@_dummy_table
PREHOOK: Output: default@test_4
POSTHOOK: query: insert into table test_4 values (1, "b", 1.5), (1, "a", 0.5), (2, "b", 1.5)
POSTHOOK: type: QUERY
POSTHOOK: Input: _dummy_database@_dummy_table
POSTHOOK: Output: default@test_4
POSTHOOK: Lineage: test_4.my_bigint SCRIPT []
POSTHOOK: Lineage: test_4.my_double SCRIPT []
POSTHOOK: Lineage: test_4.my_string SCRIPT []
PREHOOK: query: explain vectorization expression
select * from test_4 where struct(`my_bigint`, `my_string`, `my_double`)
IN (
struct(1L, "a", 1.5D),
struct(1L, "b", -0.5D),
struct(3L, "b", 1.5D),
struct(1L, "d", 1.5D),
struct(1L, "c", 1.5D),
struct(1L, "b", 2.5D),
struct(1L, "b", 0.5D),
struct(5L, "b", 1.5D),
struct(1L, "a", 0.5D),
struct(3L, "b", 1.5D)
)
PREHOOK: type: QUERY
PREHOOK: Input: default@test_4
#### A masked pattern was here ####
POSTHOOK: query: explain vectorization expression
select * from test_4 where struct(`my_bigint`, `my_string`, `my_double`)
IN (
struct(1L, "a", 1.5D),
struct(1L, "b", -0.5D),
struct(3L, "b", 1.5D),
struct(1L, "d", 1.5D),
struct(1L, "c", 1.5D),
struct(1L, "b", 2.5D),
struct(1L, "b", 0.5D),
struct(5L, "b", 1.5D),
struct(1L, "a", 0.5D),
struct(3L, "b", 1.5D)
)
POSTHOOK: type: QUERY
POSTHOOK: Input: default@test_4
#### A masked pattern was here ####
PLAN VECTORIZATION:
  enabled: true
  enabledConditionsMet: [hive.vectorized.execution.enabled IS true]

STAGE DEPENDENCIES:
  Stage-1 is a root stage
  Stage-0 depends on stages: Stage-1

STAGE PLANS:
  Stage: Stage-1
    Map Reduce
      Map Operator Tree:
          TableScan
            alias: test_4
            filterExpr: (((my_bigint = 1L) and (my_string = 'a') and (my_double = 1.5D)) or ((my_bigint = 1L) and (my_string = 'b') and (my_double = -0.5D)) or ((my_bigint = 3L) and (my_string = 'b') and (my_double = 1.5D)) or ((my_bigint = 1L) and (my_string = 'd') and (my_double = 1.5D)) or ((my_bigint = 1L) and (my_string = 'c') and (my_double = 1.5D)) or ((my_bigint = 1L) and (my_string = 'b') and (my_double = 2.5D)) or ((my_bigint = 1L) and (my_string = 'b') and (my_double = 0.5D)) or ((my_bigint = 5L) and (my_string = 'b') and (my_double = 1.5D)) or ((my_bigint = 1L) and (my_string = 'a') and (my_double = 0.5D)) or ((my_bigint = 3L) and (my_string = 'b') and (my_double = 1.5D))) (type: boolean)
            Statistics: Num rows: 3 Data size: 303 Basic stats: COMPLETE Column stats: NONE
            TableScan Vectorization:
                native: true
            Filter Operator
              Filter Vectorization:
                  className: VectorFilterOperator
                  native: true
                  predicateExpression: FilterExprOrExpr(children: FilterExprAndExpr(children: FilterLongColEqualLongScalar(col 0:bigint, val 1), FilterStringGroupColEqualStringScalar(col 1:string, val a), FilterDoubleColEqualDoubleScalar(col 2:double, val 1.5)), FilterExprAndExpr(children: FilterLongColEqualLongScalar(col 0:bigint, val 1), FilterStringGroupColEqualStringScalar(col 1:string, val b), FilterDoubleColEqualDoubleScalar(col 2:double, val -0.5)), FilterExprAndExpr(children: FilterLongColEqualLongScalar(col 0:bigint, val 3), FilterStringGroupColEqualStringScalar(col 1:string, val b), FilterDoubleColEqualDoubleScalar(col 2:double, val 1.5)), FilterExprAndExpr(children: FilterLongColEqualLongScalar(col 0:bigint, val 1), FilterStringGroupColEqualStringScalar(col 1:string, val d), FilterDoubleColEqualDoubleScalar(col 2:double, val 1.5)), FilterExprAndExpr(children: FilterLongColEqualLongScalar(col 0:bigint, val 1), FilterStringGroupColEqualStringScalar(col 1:string, val c), FilterDoubleColEqualDoubleScalar(col 2:double, val 1.5)), FilterExprAndExpr(children: FilterLongColEqualLongScalar(col 0:bigint, val 1), FilterStringGroupColEqualStringScalar(col 1:string, val b), FilterDoubleColEqualDoubleScalar(col 2:double, val 2.5)), FilterExprAndExpr(children: FilterLongColEqualLongScalar(col 0:bigint, val 1), FilterStringGroupColEqualStringScalar(col 1:string, val b), FilterDoubleColEqualDoubleScalar(col 2:double, val 0.5)), FilterExprAndExpr(children: FilterLongColEqualLongScalar(col 0:bigint, val 5), FilterStringGroupColEqualStringScalar(col 1:string, val b), FilterDoubleColEqualDoubleScalar(col 2:double, val 1.5)), FilterExprAndExpr(children: FilterLongColEqualLongScalar(col 0:bigint, val 1), FilterStringGroupColEqualStringScalar(col 1:string, val a), FilterDoubleColEqualDoubleScalar(col 2:double, val 0.5)), FilterExprAndExpr(children: FilterLongColEqualLongScalar(col 0:bigint, val 3), FilterStringGroupColEqualStringScalar(col 1:string, val b), FilterDoubleColEqualDoubleScalar(col 2:double, val 1.5)))
              predicate: (((my_bigint = 1L) and (my_string = 'a') and (my_double = 0.5D)) or ((my_bigint = 1L) and (my_string = 'a') and (my_double = 1.5D)) or ((my_bigint = 1L) and (my_string = 'b') and (my_double = -0.5D)) or ((my_bigint = 1L) and (my_string = 'b') and (my_double = 0.5D)) or ((my_bigint = 1L) and (my_string = 'b') and (my_double = 2.5D)) or ((my_bigint = 1L) and (my_string = 'c') and (my_double = 1.5D)) or ((my_bigint = 1L) and (my_string = 'd') and (my_double = 1.5D)) or ((my_bigint = 3L) and (my_string = 'b') and (my_double = 1.5D)) or ((my_bigint = 3L) and (my_string = 'b') and (my_double = 1.5D)) or ((my_bigint = 5L) and (my_string = 'b') and (my_double = 1.5D))) (type: boolean)
              Statistics: Num rows: 1 Data size: 101 Basic stats: COMPLETE Column stats: NONE
              Select Operator
                expressions: my_bigint (type: bigint), my_string (type: string), my_double (type: double)
                outputColumnNames: _col0, _col1, _col2
                Select Vectorization:
                    className: VectorSelectOperator
                    native: true
                    projectedOutputColumnNums: [0, 1, 2]
                Statistics: Num rows: 1 Data size: 101 Basic stats: COMPLETE Column stats: NONE
                File Output Operator
                  compressed: false
                  File Sink Vectorization:
                      className: VectorFileSinkOperator
                      native: false
                  Statistics: Num rows: 1 Data size: 101 Basic stats: COMPLETE Column stats: NONE
                  table:
                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat
                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat
                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe
      Execution mode: vectorized
      Map Vectorization:
          enabled: true
          enabledConditionsMet: hive.vectorized.use.vectorized.input.format IS true
          inputFormatFeatureSupport: [DECIMAL_64]
          featureSupportInUse: [DECIMAL_64]
          inputFileFormats: org.apache.hadoop.hive.ql.io.orc.OrcInputFormat
          allNative: false
          usesVectorUDFAdaptor: false
          vectorized: true

  Stage: Stage-0
    Fetch Operator
      limit: -1
      Processor Tree:
        ListSink

PREHOOK: query: select * from test_4 where struct(`my_bigint`, `my_string`, `my_double`)
IN (
struct(1L, "a", 1.5D),
struct(1L, "b", -0.5D),
struct(3L, "b", 1.5D),
struct(1L, "d", 1.5D),
struct(1L, "c", 1.5D),
struct(1L, "b", 2.5D),
struct(1L, "b", 0.5D),
struct(5L, "b", 1.5D),
struct(1L, "a", 0.5D),
struct(3L, "b", 1.5D)
)
PREHOOK: type: QUERY
PREHOOK: Input: default@test_4
#### A masked pattern was here ####
POSTHOOK: query: select * from test_4 where struct(`my_bigint`, `my_string`, `my_double`)
IN (
struct(1L, "a", 1.5D),
struct(1L, "b", -0.5D),
struct(3L, "b", 1.5D),
struct(1L, "d", 1.5D),
struct(1L, "c", 1.5D),
struct(1L, "b", 2.5D),
struct(1L, "b", 0.5D),
struct(5L, "b", 1.5D),
struct(1L, "a", 0.5D),
struct(3L, "b", 1.5D)
)
POSTHOOK: type: QUERY
POSTHOOK: Input: default@test_4
#### A masked pattern was here ####
1	a	0.5
PREHOOK: query: explain vectorization expression
select `my_bigint`, `my_string`, `my_double`, struct(`my_bigint`, `my_string`, `my_double`)
IN (
struct(1L, "a", 1.5D),
struct(1L, "b", -0.5D),
struct(3L, "b", 1.5D),
struct(1L, "d", 1.5D),
struct(1L, "c", 1.5D),
struct(1L, "b", 2.5D),
struct(1L, "b", 0.5D),
struct(5L, "b", 1.5D),
struct(1L, "a", 0.5D),
struct(3L, "b", 1.5D)
) as b from test_4
PREHOOK: type: QUERY
PREHOOK: Input: default@test_4
#### A masked pattern was here ####
POSTHOOK: query: explain vectorization expression
select `my_bigint`, `my_string`, `my_double`, struct(`my_bigint`, `my_string`, `my_double`)
IN (
struct(1L, "a", 1.5D),
struct(1L, "b", -0.5D),
struct(3L, "b", 1.5D),
struct(1L, "d", 1.5D),
struct(1L, "c", 1.5D),
struct(1L, "b", 2.5D),
struct(1L, "b", 0.5D),
struct(5L, "b", 1.5D),
struct(1L, "a", 0.5D),
struct(3L, "b", 1.5D)
) as b from test_4
POSTHOOK: type: QUERY
POSTHOOK: Input: default@test_4
#### A masked pattern was here ####
PLAN VECTORIZATION:
  enabled: true
  enabledConditionsMet: [hive.vectorized.execution.enabled IS true]

STAGE DEPENDENCIES:
  Stage-1 is a root stage
  Stage-0 depends on stages: Stage-1

STAGE PLANS:
  Stage: Stage-1
    Map Reduce
      Map Operator Tree:
          TableScan
            alias: test_4
            Statistics: Num rows: 3 Data size: 303 Basic stats: COMPLETE Column stats: NONE
            TableScan Vectorization:
                native: true
            Select Operator
              expressions: my_bigint (type: bigint), my_string (type: string), my_double (type: double), (((my_bigint = 1L) and (my_string = 'a') and (my_double = 1.5D)) or ((my_bigint = 1L) and (my_string = 'b') and (my_double = -0.5D)) or ((my_bigint = 3L) and (my_string = 'b') and (my_double = 1.5D)) or ((my_bigint = 1L) and (my_string = 'd') and (my_double = 1.5D)) or ((my_bigint = 1L) and (my_string = 'c') and (my_double = 1.5D)) or ((my_bigint = 1L) and (my_string = 'b') and (my_double = 2.5D)) or ((my_bigint = 1L) and (my_string = 'b') and (my_double = 0.5D)) or ((my_bigint = 5L) and (my_string = 'b') and (my_double = 1.5D)) or ((my_bigint = 1L) and (my_string = 'a') and (my_double = 0.5D)) or ((my_bigint = 3L) and (my_string = 'b') and (my_double = 1.5D))) (type: boolean)
              outputColumnNames: _col0, _col1, _col2, _col3
              Select Vectorization:
                  className: VectorSelectOperator
                  native: true
                  projectedOutputColumnNums: [0, 1, 2, 4]
                  selectExpressions: VectorUDFAdaptor((((my_bigint = 1L) and (my_string = 'a') and (my_double = 1.5D)) or ((my_bigint = 1L) and (my_string = 'b') and (my_double = -0.5D)) or ((my_bigint = 3L) and (my_string = 'b') and (my_double = 1.5D)) or ((my_bigint = 1L) and (my_string = 'd') and (my_double = 1.5D)) or ((my_bigint = 1L) and (my_string = 'c') and (my_double = 1.5D)) or ((my_bigint = 1L) and (my_string = 'b') and (my_double = 2.5D)) or ((my_bigint = 1L) and (my_string = 'b') and (my_double = 0.5D)) or ((my_bigint = 5L) and (my_string = 'b') and (my_double = 1.5D)) or ((my_bigint = 1L) and (my_string = 'a') and (my_double = 0.5D)) or ((my_bigint = 3L) and (my_string = 'b') and (my_double = 1.5D))))(children: VectorUDFAdaptor(((my_bigint = 1L) and (my_string = 'a') and (my_double = 1.5D)))(children: LongColEqualLongScalar(col 0:bigint, val 1) -> 4:boolean, StringGroupColEqualStringScalar(col 1:string, val a) -> 5:boolean, DoubleColEqualDoubleScalar(col 2:double, val 1.5) -> 6:boolean) -> 7:boolean, VectorUDFAdaptor(((my_bigint = 1L) and (my_string = 'b') and (my_double = -0.5D)))(children: LongColEqualLongScalar(col 0:bigint, val 1) -> 4:boolean, StringGroupColEqualStringScalar(col 1:string, val b) -> 5:boolean, DoubleColEqualDoubleScalar(col 2:double, val -0.5) -> 6:boolean) -> 8:boolean, VectorUDFAdaptor(((my_bigint = 3L) and (my_string = 'b') and (my_double = 1.5D)))(children: LongColEqualLongScalar(col 0:bigint, val 3) -> 4:boolean, StringGroupColEqualStringScalar(col 1:string, val b) -> 5:boolean, DoubleColEqualDoubleScalar(col 2:double, val 1.5) -> 6:boolean) -> 9:boolean, VectorUDFAdaptor(((my_bigint = 1L) and (my_string = 'd') and (my_double = 1.5D)))(children: LongColEqualLongScalar(col 0:bigint, val 1) -> 4:boolean, StringGroupColEqualStringScalar(col 1:string, val d) -> 5:boolean, DoubleColEqualDoubleScalar(col 2:double, val 1.5) -> 6:boolean) -> 10:boolean, VectorUDFAdaptor(((my_bigint = 1L) and (my_string = 'c') and (my_double = 1.5D)))(children: LongColEqualLongScalar(col 0:bigint, val 1) -> 4:boolean, StringGroupColEqualStringScalar(col 1:string, val c) -> 5:boolean, DoubleColEqualDoubleScalar(col 2:double, val 1.5) -> 6:boolean) -> 11:boolean, VectorUDFAdaptor(((my_bigint = 1L) and (my_string = 'b') and (my_double = 2.5D)))(children: LongColEqualLongScalar(col 0:bigint, val 1) -> 4:boolean, StringGroupColEqualStringScalar(col 1:string, val b) -> 5:boolean, DoubleColEqualDoubleScalar(col 2:double, val 2.5) -> 6:boolean) -> 12:boolean, VectorUDFAdaptor(((my_bigint = 1L) and (my_string = 'b') and (my_double = 0.5D)))(children: LongColEqualLongScalar(col 0:bigint, val 1) -> 4:boolean, StringGroupColEqualStringScalar(col 1:string, val b) -> 5:boolean, DoubleColEqualDoubleScalar(col 2:double, val 0.5) -> 6:boolean) -> 13:boolean, VectorUDFAdaptor(((my_bigint = 5L) and (my_string = 'b') and (my_double = 1.5D)))(children: LongColEqualLongScalar(col 0:bigint, val 5) -> 4:boolean, StringGroupColEqualStringScalar(col 1:string, val b) -> 5:boolean, DoubleColEqualDoubleScalar(col 2:double, val 1.5) -> 6:boolean) -> 14:boolean, VectorUDFAdaptor(((my_bigint = 1L) and (my_string = 'a') and (my_double = 0.5D)))(children: LongColEqualLongScalar(col 0:bigint, val 1) -> 4:boolean, StringGroupColEqualStringScalar(col 1:string, val a) -> 5:boolean, DoubleColEqualDoubleScalar(col 2:double, val 0.5) -> 6:boolean) -> 15:boolean, VectorUDFAdaptor(((my_bigint = 3L) and (my_string = 'b') and (my_double = 1.5D)))(children: LongColEqualLongScalar(col 0:bigint, val 3) -> 4:boolean, StringGroupColEqualStringScalar(col 1:string, val b) -> 5:boolean, DoubleColEqualDoubleScalar(col 2:double, val 1.5) -> 6:boolean) -> 16:boolean) -> 4:boolean
              Statistics: Num rows: 3 Data size: 303 Basic stats: COMPLETE Column stats: NONE
              File Output Operator
                compressed: false
                File Sink Vectorization:
                    className: VectorFileSinkOperator
                    native: false
                Statistics: Num rows: 3 Data size: 303 Basic stats: COMPLETE Column stats: NONE
                table:
                    input format: org.apache.hadoop.mapred.SequenceFileInputFormat
                    output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat
                    serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe
      Execution mode: vectorized
      Map Vectorization:
          enabled: true
          enabledConditionsMet: hive.vectorized.use.vectorized.input.format IS true
          inputFormatFeatureSupport: [DECIMAL_64]
          featureSupportInUse: [DECIMAL_64]
          inputFileFormats: org.apache.hadoop.hive.ql.io.orc.OrcInputFormat
          allNative: false
          usesVectorUDFAdaptor: true
          vectorized: true

  Stage: Stage-0
    Fetch Operator
      limit: -1
      Processor Tree:
        ListSink

PREHOOK: query: select `my_bigint`, `my_string`, `my_double`, struct(`my_bigint`, `my_string`, `my_double`)
IN (
struct(1L, "a", 1.5D),
struct(1L, "b", -0.5D),
struct(3L, "b", 1.5D),
struct(1L, "d", 1.5D),
struct(1L, "c", 1.5D),
struct(1L, "b", 2.5D),
struct(1L, "b", 0.5D),
struct(5L, "b", 1.5D),
struct(1L, "a", 0.5D),
struct(3L, "b", 1.5D)
) as b from test_4
PREHOOK: type: QUERY
PREHOOK: Input: default@test_4
#### A masked pattern was here ####
POSTHOOK: query: select `my_bigint`, `my_string`, `my_double`, struct(`my_bigint`, `my_string`, `my_double`)
IN (
struct(1L, "a", 1.5D),
struct(1L, "b", -0.5D),
struct(3L, "b", 1.5D),
struct(1L, "d", 1.5D),
struct(1L, "c", 1.5D),
struct(1L, "b", 2.5D),
struct(1L, "b", 0.5D),
struct(5L, "b", 1.5D),
struct(1L, "a", 0.5D),
struct(3L, "b", 1.5D)
) as b from test_4
POSTHOOK: type: QUERY
POSTHOOK: Input: default@test_4
#### A masked pattern was here ####
1	a	0.5	true
1	b	1.5	false
2	b	1.5	false
